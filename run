#!/usr/bin/env bash
set -euo pipefail

NUM_SERVERS=3
DEBUG=0
WAIT_FOR_SERVICES=0
TESTENV=(sudo -n tools/testenv/testenv.sh)

sudo -v || {
  echo "need sudo"
  exit 1
}

bg_pids=()
mkdir -p logs
rm -f logs/*

# Run command in background, tee its log, and stream to stdout
run_bg() {
  local name=$1
  shift
  local logfile="logs/${name}.log"
  : >"$logfile"

  "$@" >"$logfile" 2>&1 &
  bg_pids+=($!)

  tail -F "$logfile" &
  bg_pids+=($!)
}

# Run a foreground command, tee its log, stream it live, and wait only for the command
# Each name must be unique, otherwise tail will truncate the log file
run_bg_and_wait() {
  local name=$1
  shift
  local logfile="logs/${name}.log"
  : >"$logfile"

  # Tail in background
  tail -F "$logfile" &
  bg_pids+=($!)

  # Run the command in background
  "$@" >"$logfile" 2>&1 &
  local cmd_pid=$!
  wait "$cmd_pid"
}

cleanup() {
  for pid in "${bg_pids[@]}"; do
    kill "$pid" 2>/dev/null || true
    wait "$pid" 2>/dev/null || true
  done
}
trap cleanup EXIT SIGINT SIGTERM

usage() {
  echo "Usage: $0 [-s NUM_SERVERS] [-d] [-w]" >&2
  echo "  -s NUM_SERVERS  Number of server replicas (default: 3)"
  echo "  -d              Use debug build"
  echo "  -w              Wait for background services after client finishes"
  exit 1
}

# Parse args
while getopts "s:dw" opt; do
  case $opt in
  s) NUM_SERVERS=$OPTARG ;;
  d) DEBUG=1 ;;
  w) WAIT_FOR_SERVICES=1 ;;
  *) usage ;;
  esac
done

if [[ "$DEBUG" -eq 1 ]]; then
  TARGET_DIR="target/debug"
  cargo build --quiet
else
  TARGET_DIR="target/release"
  cargo build --release --quiet
fi

# Setup testenvs
for env in $(seq 1 "$NUM_SERVERS" | sed 's/^/server/') writer; do
  "${TESTENV[@]}" setup --name "$env" --legacy-ip >/dev/null 2>&1 || true

  # Disable UDP TX checksum offloading
  "${TESTENV[@]}" exec -n "$env" -- \
    bash -c "ethtool -K veth0 tx-checksum-ip-generic off >/dev/null 2>&1 || true"

  # Attach xdp-pass with warn-level logs
  run_bg "veth0_$env" "${TESTENV[@]}" exec -n "$env" -- \
    bash -c "RUST_LOG=warn $TARGET_DIR/xdp-pass --iface veth0"
done

# Run servers
for i in $(seq 1 "$NUM_SERVERS"); do
  env="server$i"
  run_bg "$env" sudo -E bash -c \
    "RUST_LOG=info $TARGET_DIR/server \
     --iface $env --num-servers=$NUM_SERVERS --server-id $i"
done

# Run writer with info logging
run_bg "writer" sudo -E bash -c \
  "RUST_LOG=info $TARGET_DIR/writer \
   --iface writer --num-servers=$NUM_SERVERS"

# Run reader on server1
run_bg "reader1" sudo -E bash -c \
  "RUST_LOG=info $TARGET_DIR/reader \
   --iface server1 --num-servers=$NUM_SERVERS --node-id 1"

# Wait for services to initialize
sleep 1
echo

# Write
writer_ip=$(
  "${TESTENV[@]}" -n writer status |
    awk '/Iface:/ {print $4}' |
    cut -d'/' -f1
)
run_bg_and_wait "client_write_42" "${TESTENV[@]}" exec -n writer -- bash -c "
  RUST_LOG=info $TARGET_DIR/client write $writer_ip 42"
echo

run_bg_and_wait "client_write_69" "${TESTENV[@]}" exec -n writer -- bash -c "
  RUST_LOG=info $TARGET_DIR/client write $writer_ip 69"
echo

# Read
reader1_ip=$(
  "${TESTENV[@]}" -n server1 status |
    awk '/Iface:/ {print $4}' |
    cut -d'/' -f1
)
run_bg_and_wait "client_read_0" "${TESTENV[@]}" exec -n server1 -- bash -c "
  RUST_LOG=info $TARGET_DIR/client read $reader1_ip"

# Leave the services running if requested
if [[ "$WAIT_FOR_SERVICES" -eq 1 ]]; then
  wait
fi
